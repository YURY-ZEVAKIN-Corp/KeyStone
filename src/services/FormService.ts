import { EventEmitter } from "../utils/EventEmitter";
import { FormModalState, FormButtonConfig } from "../types/form.types";
import { getFormRegistryItem } from "../registry/FormRegistry";
import { IService, requireService } from "./ServiceRegistry";
import { v4 as uuidv4 } from "uuid";

// Events generated by FormService
export interface FormServiceEvents {
  "form:open": (state: FormModalState) => void;
  "form:close": () => void;
}

class FormServiceClass extends EventEmitter implements IService {
  public readonly serviceName = "FormService";
  private currentFormState: FormModalState | null = null;

  /**
   * Initialize the FormService
   */
  public initialize(): void {
    console.log("FormService initialized");
  }

  /**
   * Dispose the FormService
   */
  public dispose(): void {
    if (this.currentFormState?.isOpen) {
      this.rejectForm(new Error("FormService is being disposed"));
    }
    this.removeAllListeners();
    console.log("FormService disposed");
  }

  /**
   * Get WaitingService from registry
   */
  private getWaitingService() {
    return requireService("WaitingService") as any;
  }

  /**
   * Opens a form with given ID and input data
   * @param formId Form identifier from registry
   * @param inputModel Input data model for the form
   * @param buttonConfig Configuration for form buttons (overrides registry config)
   * @param formEntityId Optional, will be generated if not provided
   * @returns Promise that resolves with form output data
   */
  public openForm<TInput = any, TOutput = any>(
    formId: string,
    inputModel: TInput = {} as TInput,
    buttonConfig?: FormButtonConfig,
    formEntityId?: string, // Optional, will be generated if not provided
  ): Promise<TOutput> {
    return new Promise<TOutput>((resolve, reject) => {
      // If there's already an open form, close it with rejection
      if (this.currentFormState?.isOpen) {
        this.currentFormState.reject?.(
          new Error("Form was replaced by another form"),
        );
      }

      // Get button config from parameter, registry, or use defaults
      let finalButtonConfig: FormButtonConfig = {
        okButton: true,
        cancelButton: true,
        saveButton: false,
        yesButton: false,
        noButton: false,
      };

      if (buttonConfig) {
        finalButtonConfig = buttonConfig;
      } else {
        try {
          const registryItem = getFormRegistryItem(formId);
          if (registryItem.buttonConfig) {
            finalButtonConfig = registryItem.buttonConfig;
          }
        } catch (err) {
          // If registry item not found, use defaults
          console.warn(
            "Form registry item not found for " +
              formId +
              ", using default button config",
          );
        }
      }

      // Generate unique formEntityId if not provided
      const entityId = formEntityId || uuidv4();

      const newState: FormModalState = {
        isOpen: true,
        formId,
        inputModel,
        resolve: resolve as (value: any) => void,
        reject,
        buttonConfig: finalButtonConfig,
        formEntityId: entityId,
      };

      this.currentFormState = newState;
      this.emit("form:open", newState);
    });
  }

  /**
   * Closes current form with successful result
   * @param outputModel Form output data
   */
  public resolveForm(outputModel: any): void {
    if (this.currentFormState?.resolve) {
      this.currentFormState.resolve(outputModel);
      this.closeForm();
    }
  }

  /**
   * Closes current form with rejection (Cancel)
   * @param reason Rejection reason
   */
  public rejectForm(reason?: any): void {
    if (this.currentFormState?.reject) {
      this.currentFormState.reject(reason || new Error("Form cancelled"));
      this.closeForm();
    }
  }

  /**
   * Closes form without calling callbacks
   */
  private closeForm(): void {
    this.currentFormState = null;
    this.emit("form:close");
  }

  /**
   * Gets current form state
   */
  public getCurrentFormState(): FormModalState | null {
    return this.currentFormState;
  }

  /**
   * Checks if a form is currently open
   */
  public isFormOpen(): boolean {
    return this.currentFormState?.isOpen || false;
  }

  /**
   * Opens a form with automatic waiting animation during async operations
   * @param formId Form identifier from registry
   * @param inputModel Input data model for the form
   * @param asyncOperation Optional async operation to perform with waiting animation
   * @param waitingMessage Message to show during async operation
   * @param buttonConfig Configuration for form buttons (overrides registry config)
   * @param formEntityId Optional, will be generated if not provided
   * @returns Promise that resolves with form output data
   */
  public async openFormWithWaiting<TInput = any, TOutput = any>(
    formId: string,
    inputModel: TInput = {} as TInput,
    asyncOperation?: () => Promise<TInput>,
    waitingMessage = "Loading form...",
    buttonConfig?: FormButtonConfig,
    formEntityId?: string,
  ): Promise<TOutput> {
    let finalInputModel = inputModel;

    // If there's an async operation, show waiting animation
    if (asyncOperation) {
      const waitingService = this.getWaitingService();
      finalInputModel = await waitingService.withPromise(asyncOperation(), {
        message: waitingMessage,
        overlay: true,
        size: "medium",
        theme: "primary",
      });
    }

    return this.openForm<TInput, TOutput>(
      formId,
      finalInputModel,
      buttonConfig,
      formEntityId,
    );
  }

  /**
   * Resolves form with automatic waiting animation during async save operation
   * @param outputModel Form output data
   * @param saveOperation Optional async save operation
   * @param waitingMessage Message to show during save operation
   */
  public async resolveFormWithWaiting(
    outputModel: any,
    saveOperation?: (data: any) => Promise<any>,
    waitingMessage = "Saving...",
  ): Promise<void> {
    if (saveOperation) {
      const waitingService = this.getWaitingService();
      await waitingService.withPromise(saveOperation(outputModel), {
        message: waitingMessage,
        overlay: true,
        size: "medium",
        theme: "primary",
      });
    }

    this.resolveForm(outputModel);
  }
}

// Export the class for registration
export { FormServiceClass };

// Factory function for service registry
export function createFormService(): FormServiceClass {
  return new FormServiceClass();
}
