import { EventEmitter } from "../utils/EventEmitter";
import { FormModalState, FormButtonConfig } from "../types/form.types";
import { getFormRegistryItem } from "../registry/FormRegistry";
import { v4 as uuidv4 } from "uuid";

// Events generated by FormService
export interface FormServiceEvents {
  "form:open": (state: FormModalState) => void;
  "form:close": () => void;
}

class FormServiceClass extends EventEmitter {
  private currentFormState: FormModalState | null = null;

  /**
   * Opens a form with given ID and input data
   * @param formId Form identifier from registry
   * @param inputModel Input data model for the form
   * @param buttonConfig Configuration for form buttons (overrides registry config)
   * @param formEntityId Optional, will be generated if not provided
   * @returns Promise that resolves with form output data
   */
  public openForm<TInput = any, TOutput = any>(
    formId: string,
    inputModel: TInput = {} as TInput,
    buttonConfig?: FormButtonConfig,
    formEntityId?: string, // Optional, will be generated if not provided
  ): Promise<TOutput> {
    return new Promise<TOutput>((resolve, reject) => {
      // If there's already an open form, close it with rejection
      if (this.currentFormState?.isOpen) {
        this.currentFormState.reject?.(
          new Error("Form was replaced by another form"),
        );
      }

      // Get button config from parameter, registry, or use defaults
      let finalButtonConfig: FormButtonConfig = {
        okButton: true,
        cancelButton: true,
        saveButton: false,
        yesButton: false,
        noButton: false,
      };

      if (buttonConfig) {
        finalButtonConfig = buttonConfig;
      } else {
        try {
          const registryItem = getFormRegistryItem(formId);
          if (registryItem.buttonConfig) {
            finalButtonConfig = registryItem.buttonConfig;
          }
        } catch (err) {
          // If registry item not found, use defaults
          console.warn(
            "Form registry item not found for " +
              formId +
              ", using default button config",
          );
        }
      }

      // Generate unique formEntityId if not provided
      const entityId = formEntityId || uuidv4();

      const newState: FormModalState = {
        isOpen: true,
        formId,
        inputModel,
        resolve: resolve as (value: any) => void,
        reject,
        buttonConfig: finalButtonConfig,
        formEntityId: entityId,
      };

      this.currentFormState = newState;
      this.emit("form:open", newState);
    });
  }

  /**
   * Closes current form with successful result
   * @param outputModel Form output data
   */
  public resolveForm(outputModel: any): void {
    if (this.currentFormState?.resolve) {
      this.currentFormState.resolve(outputModel);
      this.closeForm();
    }
  }

  /**
   * Closes current form with rejection (Cancel)
   * @param reason Rejection reason
   */
  public rejectForm(reason?: any): void {
    if (this.currentFormState?.reject) {
      this.currentFormState.reject(reason || new Error("Form cancelled"));
      this.closeForm();
    }
  }

  /**
   * Closes form without calling callbacks
   */
  private closeForm(): void {
    this.currentFormState = null;
    this.emit("form:close");
  }

  /**
   * Gets current form state
   */
  public getCurrentFormState(): FormModalState | null {
    return this.currentFormState;
  }

  /**
   * Checks if a form is currently open
   */
  public isFormOpen(): boolean {
    return this.currentFormState?.isOpen || false;
  }
}

// Export singleton instance
export const FormService = new FormServiceClass();

// Update FormModalState type to include formEntityId in your types if not already present.
// Each form instance now has a unique formEntityId, generated if not provided.
// To support routing, you should use this formEntityId in your router (e.g., /form/[formType]/[formEntityId]).
// Example usage for navigation (not in this file):
//   navigate(`/form/${formId}/${entityId}`);
